<#
 #
 # Copyright (C) 2015 - 2018 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file asset_DELETE.ecpp
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \brief Implementation of DELETE operation on any asset
 */
 #><%pre>
#include <sys/types.h>
#include <unistd.h>
#include <mutex>
#include <map>
#include <string>
#include <regex>

#include "shared/data.h"
#include "shared/configure_inform.h"
#include <fty_common_rest_helpers.h>
#include <fty_common_db_asset.h>
#include <fty_common_macros.h>
#include <fty_common_rest_audit_log.h>
#include <cxxtools/split.h>
</%pre>

<%application>
std::mutex g_deleteAssetMutex;
</%application>

<%thread scope="global">
asset_manager     asset_mgr;
</%thread>
<%request scope="global">
UserInfo user;
bool database_ready;
</%request>
<%cpp>
{
    // verify server is ready
    if (!database_ready) {
        log_debug ("Database is not ready yet.");
        std::string err =  TRANSLATE_ME ("Database is not ready yet, please try again after a while.");
        log_error_audit ("Request DELETE asset FAILED");
        http_die ("internal-error", err.c_str ());
    }

    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
        {BiosProfile::Admin,     "D"}
    };

    std::string audit_msg = std::string ("Request DELETE asset FAILED");
    CHECK_USER_PERMISSIONS_OR_DIE_AUDIT (PERMISSIONS, audit_msg.empty () ? nullptr : audit_msg.c_str ());

    std::string idsStr = qparam.param("ids");
    if (!idsStr.empty()) {
        std::vector<std::string> idsNotSorted;
        // split and sanity check
        try {
            cxxtools::split(",", idsStr, std::back_inserter(idsNotSorted));
        } catch (const std::exception& e) {
            std::string err = TRANSLATE_ME ("ID list is not valid");
            log_error_audit ("Request DELETE asset ids %s FAILED", idsStr.c_str());
            http_die ("request-param-bad", "ids", idsStr.c_str(), err.c_str());
        }

        for(const auto& id: ids) {
            if (!persist::is_ok_name(id.c_str())) {
                std::string err = TRANSLATE_ME("valid asset name");
                log_error_audit("Request DELETE asset id %s FAILED", id.c_str());
                http_die ("request-param-bad", "id", id.c_str(), err.c_str());
            }
        }
        // end sanity checks


        //pre sort
        std::vector<std::string> idsOther;
        
        std::vector<std::string> idsSts;
        std::vector<std::string> idsPdu;
        std::vector<std::string> idsEpdu;
        std::vector<std::string> idsUps;
        
        std::vector<std::string> idsFeed;
        
        std::vector<std::string> idsRack;
        std::vector<std::string> idsRow;
        std::vector<std::string> idsRoom;
        std::vector<std::string> idsDC;
        
        for( const std::string & id : idsNotSorted ) {
            if( std::regex_match (id, std::regex("(sts-)(.*)") ) ) {
                idsSts.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(pdu-)(.*)") ) ) {
                idsPdu.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(epdu-)(.*)") ) ) {
                idsEpdu.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(ups-)(.*)") ) ) {
                idsUps.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(feed-)(.*)") ) ) {
                idsFeed.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(rack-)(.*)") ) ) {
                idsRack.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(row-)(.*)") ) ) {
                idsRow.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(room-)(.*)") ) ) {
                idsRoom.push_back(id);
            }
            else if( std::regex_match (id, std::regex("(datacenter-)(.*)") ) ) {
                idsDC.push_back(id);
            }
            else {
                idsOther.push_back(id);
            }
            
        }
        
        std::vector<std::string> idsSorted;
        
        idsSorted.insert(idsSorted.end(), idsOther.begin(), idsOther.end());
        
        idsSorted.insert(idsSorted.end(), idsSts.begin(), idsSts.end());
        idsSorted.insert(idsSorted.end(), idsPdu.begin(), idsPdu.end());
        idsSorted.insert(idsSorted.end(), idsEpdu.begin(), idsEpdu.end());
        idsSorted.insert(idsSorted.end(), idsUps.begin(), idsUps.end());
        
        idsSorted.insert(idsSorted.end(), idsFeed.begin(), idsFeed.end());
        
        idsSorted.insert(idsSorted.end(), idsRack.begin(), idsRack.end());
        idsSorted.insert(idsSorted.end(), idsRow.begin(), idsRow.end());
        idsSorted.insert(idsSorted.end(), idsRoom.begin(), idsRoom.end());
        idsSorted.insert(idsSorted.end(), idsDC.begin(), idsDC.end());

        std::unique_lock<std::mutex> lock1(g_deleteAssetMutex);

        std::vector<std::pair<std::string,uint32_t>> dbIds;
        for(const auto& id: idsSorted) {
            // get id by name
            int64_t dbid = DBAssets::name_to_asset_id(id);
            if (dbid == -1) {
                lock1.unlock();
                log_error_audit("Request DELETE asset id %s FAILED", id.c_str());
                http_die("element-not-found", id.c_str());
            }
            if (dbid == -2) {
                lock1.unlock();
                std::string err =  TRANSLATE_ME("Database failure");
                log_error_audit("Request DELETE asset id %s FAILED", id.c_str());
                http_die("internal-error", err.c_str());
            }
            dbIds.push_back({id, dbid});
        }

        //perform the delete in lazy mode

        bool atLeastOneIsDeleted = false;
        std::map<std::string, std::string> mapAssetNameDeleteError;
        std::map<std::string, db_a_elmnt_t> mapAssetNameDeletedRow;

        while(atLeastOneIsDeleted) {
            atLeastOneIsDeleted = false;

            auto it = dbIds.begin()
            while(it != dbIds.end()) {
                
                std::string assetName = it->first;
                uint32_t dbid = it->second;
                
                db_a_elmnt_t row;
                auto ret = asset_mgr.delete_item (dbid, row);

                if ( ret.status == 0 ) {
                    std::string reason = TRANSLATE_ME ("Asset is in use, remove children/power source links first.");
                    log_debug ("-- DELETE asset id %s FAILED: Asset is in use, remove children/power source links first.", assetName.c_str());
                    mapAssetNameDeleteError[assetName] = reason;

                    ++it;
                }
                else {
                    log_debug ("-- DELETE asset id %s SUCCEED.", assetName.c_str());
                    mapAssetNameDeleteError[assetName] = "";
                    mapAssetNameDeletedRow[assetName] = row;

                    atLeastOneIsDeleted = true;
                    it = dbIds.erase(it);
                }
            }
        }

        try {
            //create the answer for UI
            cxxtools::SerializationInfo si;
            si.setCategory(cxxtools::SerializationInfo::Category::Array);

            bool someAreOK = false;

            for( const auto &e : mapAssetNameDeleteError) {
                cxxtools::SerializationInfo val;
                val.setCategory(cxxtools::SerializationInfo::Category::Object);
                val.addValue("asset", e.first);

                if (e.second.empty()) {
                    val.addValue("status", "OK");
                    log_info_audit ("-- DELETE asset id %s SUCCEED.", e.first.c_str());
                    someAreOK = true;
                } else {
                    val.addValue("status", "ERROR");
                    val.addValue("reason", e.second);
                    log_info_audit ("-- DELETE asset id %s FAILED: %s", e.first.c_str(), e.second.c_str());
                }
                si.addMember("") <<= val;
            }

            cxxtools::JsonSerializer serializer(reply.out());
            serializer.serialize(si).finish();

            //send notification
            std::string agent_name = utils::generate_mlm_client_id ("web.asset_delete");
            for( const auto &e : mapAssetNameDeletedRow) {
                send_configure (e.second, persist::asset_operation::DELETE, agent_name);
            }

            if (!someAreOk) {
                log_info_audit ("Request DELETE assets ids %s FAILED", idsStr.c_str ());
                return HTTP_CONFLICT;
            }

            log_info_audit ("Request DELETE assets ids %s SUCCESS", idsStr.c_str ());
            return HTTP_OK;

        } catch (const std::runtime_error &e) {
            log_error ("%s", e.what ());
            std::string msg = TRANSLATE_ME ("Error during configuration sending of asset change notification. Consult system log.");
            log_error_audit("Request DELETE asset id %s FAILED", idsStr.c_str());
            http_die("internal-error", msg.c_str());
        }

    } else {
        std::string id = request.getArg ("id");
        if ( id.empty () ) {
            log_error_audit ("Request DELETE asset FAILED");
            http_die ("request-param-required", "id");
        }

        if ( !persist::is_ok_name (id.c_str ()) ) {
            std::string err = TRANSLATE_ME ("valid asset name");
            log_error_audit ("Request DELETE asset id %s FAILED", id.c_str ());
            http_die ("request-param-bad", "id", id.c_str (), err.c_str ());
        }
        std::string checked_id = id;
        std::unique_lock<std::mutex> lock1(g_deleteAssetMutex);

        // get id by name
        int64_t dbid = DBAssets::name_to_asset_id (checked_id);
        if (dbid == -1) {
            lock1.unlock();
            log_error_audit ("Request DELETE asset id %s FAILED", id.c_str ());
            http_die ("element-not-found", checked_id.c_str ());
        }
        if (dbid == -2) {
            lock1.unlock();
            std::string err =  TRANSLATE_ME ("Database failure");
            log_error_audit ("Request DELETE asset id %s FAILED", id.c_str ());
            http_die ("internal-error", err.c_str ());
        }

        // delete it
        db_a_elmnt_t row;
        auto ret = asset_mgr.delete_item (dbid, row);
        lock1.unlock();

        if ( ret.status == 0 ) {
            if ( ret.errsubtype == DB_ERROR_NOTFOUND ) {
                log_error_audit ("Request DELETE asset id %s FAILED", id.c_str ());
                http_die ("element-not-found", checked_id.c_str ());
            }
            else {
                std::string reason = TRANSLATE_ME ("Asset is in use, remove children/power source links first.");
                log_error_audit ("Request DELETE asset id %s FAILED", id.c_str ());
                http_die ("data-conflict",  checked_id.c_str (), reason.c_str ());
            }
        }
        // here we are -> delete was successful
        // ATTENTION:  1. sending messages is "hidden functionality" from user
        //             2. if any error would occur during the sending message,
        //                user will never know if element was actually deleted
        //                or not

        // this code can be executed in multiple threads -> agent's name should
        // be unique at the every moment
        std::string agent_name = utils::generate_mlm_client_id ("web.asset_delete");
        try {
            send_configure (row, persist::asset_operation::DELETE, agent_name);
            log_info_audit ("Request DELETE asset id %s SUCCESS", id.c_str ());
</%cpp>
{}
<%cpp>
            return HTTP_OK;
        }
        catch (const std::runtime_error &e) {
            log_error ("%s", e.what ());
            std::string msg = TRANSLATE_ME ("Error during configuration sending of asset change notification. Consult system log.");
            log_error_audit ("Request DELETE asset id %s FAILED", id.c_str ());
            http_die ("internal-error", msg.c_str ());
        }
    }
}
</%cpp>
